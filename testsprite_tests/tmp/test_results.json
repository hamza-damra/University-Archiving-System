[
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "511f025f-5547-41a3-ac3a-2ebb38cbe9e1",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC001-verify_jwt_authentication_and_hod_role_validation",
    "description": "Test that all API endpoints require valid JWT tokens and verify that the user has the HOD role with proper department scoping. Unauthorized or invalid tokens should be rejected.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nLOGIN_ENDPOINT = \"http://localhost:8080/api/auth/login\"\nTIMEOUT = 30\n\nHOD_EMAIL = \"hod.ce@hod.alquds.edu\"\nHOD_PASSWORD = \"Hh@#2021\"\n\n\ndef test_verify_jwt_authentication_and_hod_role_validation():\n    # Attempt accessing endpoint without token - expect 401 Unauthorized\n    resp = requests.get(f\"{BASE_URL}/dashboard\", timeout=TIMEOUT)\n    assert resp.status_code == 401 or resp.status_code == 403, f\"Expected 401/403 for no token but got {resp.status_code}\"\n\n    # Attempt login as HOD to get JWT token\n    login_payload = {\n        \"email\": HOD_EMAIL,\n        \"password\": HOD_PASSWORD\n    }\n    login_resp = requests.post(LOGIN_ENDPOINT, json=login_payload, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n    login_json = login_resp.json()\n\n    token = login_json.get(\"accessToken\")\n    assert token is not None, \"No accessToken found in login response\"\n\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Access dashboard endpoint with valid token - expect 200 OK\n    dashboard_resp = requests.get(f\"{BASE_URL}/dashboard\", headers=headers, timeout=TIMEOUT)\n    assert dashboard_resp.status_code == 200, f\"Dashboard access failed with valid token, status {dashboard_resp.status_code}\"\n\n    # Access another endpoint that requires HOD role, e.g. professors list\n    professors_resp = requests.get(f\"{BASE_URL}/professors\", headers=headers, timeout=TIMEOUT)\n    assert professors_resp.status_code == 200, f\"Professors endpoint access failed, status {professors_resp.status_code}\"\n\n    # Access with invalid token - expect 401 or 403\n    invalid_headers = {\"Authorization\": \"Bearer invalidtoken123\"}\n    invalid_token_resp = requests.get(f\"{BASE_URL}/dashboard\", headers=invalid_headers, timeout=TIMEOUT)\n    assert invalid_token_resp.status_code == 401 or invalid_token_resp.status_code == 403, f\"Expected 401/403 for invalid token but got {invalid_token_resp.status_code}\"\n\n\ntest_verify_jwt_authentication_and_hod_role_validation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 44, in <module>\n  File \"<string>\", line 26, in test_verify_jwt_authentication_and_hod_role_validation\nAssertionError: No accessToken found in login response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.536Z",
    "modified": "2026-01-13T13:16:06.885Z"
  },
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "6f6b61a8-6801-4d2b-97a7-ae1118eba77f",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC002-test_hod_dashboard_statistics_and_filters",
    "description": "Verify that the HOD dashboard API returns accurate statistics for professors, courses, submissions, missing, and overdue documents for the selected academic year and semester, and that filters update the data dynamically.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nAUTH_URL = \"http://localhost:8080/api/auth/login\"\nHOD_EMAIL = \"hod.ce@hod.alquds.edu\"\nHOD_PASSWORD = \"Hh@#2021\"\nTIMEOUT = 30\n\ndef test_hod_dashboard_statistics_and_filters():\n    # Authenticate to get JWT token with HOD role\n    credentials = {\n        \"email\": HOD_EMAIL,\n        \"password\": HOD_PASSWORD\n    }\n    try:\n        auth_resp = requests.post(\n            AUTH_URL,\n            json=credentials,\n            timeout=TIMEOUT\n        )\n        assert auth_resp.status_code == 200, f\"Authentication failed: {auth_resp.text}\"\n        auth_json = auth_resp.json()\n        token = auth_json.get(\"token\") or auth_json.get(\"accessToken\")\n        assert token, \"JWT token not found in authentication response\"\n    except Exception as e:\n        raise AssertionError(f\"Authentication request failed: {e}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n\n    # First, retrieve valid academic years and semesters from API if possible\n    # Assuming GET /academicYears returns list of years with semesters\n    try:\n        years_resp = requests.get(f\"{BASE_URL}/academicYears\", headers=headers, timeout=TIMEOUT)\n        assert years_resp.status_code == 200, f\"Failed to get academic years: {years_resp.text}\"\n        years_data = years_resp.json()\n        assert isinstance(years_data, list) and len(years_data) > 0, \"No academic years found\"\n\n        # Select first academic year and its first semester as test params\n        academic_year = years_data[0].get(\"year\")\n        semesters = years_data[0].get(\"semesters\")\n        assert semesters and isinstance(semesters, list), \"No semesters found for academic year\"\n        semester = semesters[0]\n    except Exception as e:\n        raise AssertionError(f\"Error retrieving academic years/semesters: {e}\")\n\n    # Define the dashboard statistics URL with query parameters for year and semester\n    dashboard_stats_url = f\"{BASE_URL}/dashboard/statistics?academicYear={academic_year}&semester={semester}\"\n\n    try:\n        # Request dashboard statistics for selected year and semester\n        stats_resp = requests.get(dashboard_stats_url, headers=headers, timeout=TIMEOUT)\n        assert stats_resp.status_code == 200, f\"Dashboard statistics request failed: {stats_resp.text}\"\n        stats = stats_resp.json()\n\n        # Validate response contains required keys and reasonable integer values >= 0\n        required_fields = [\"professorsCount\", \"coursesCount\", \"submissionsCount\", \"missingDocumentsCount\", \"overdueDocumentsCount\"]\n        for field in required_fields:\n            assert field in stats, f\"Missing field in dashboard statistics: {field}\"\n            value = stats[field]\n            assert isinstance(value, int) and value >= 0, f\"Invalid value for {field}: {value}\"\n\n    except Exception as e:\n        raise AssertionError(f\"Error validating dashboard statistics: {e}\")\n\n    # Now test dynamic update of filters - simulate changing academic year and semester if more than one available\n    try:\n        # If more than one academic year or semester, pick another to verify data changes\n        if len(years_data) > 1 or len(semesters) > 1:\n            # Try a different combination\n            alt_academic_year = academic_year\n            alt_semester = semester\n            if len(semesters) > 1:\n                alt_semester = semesters[1]\n            elif len(years_data) > 1:\n                alt_academic_year = years_data[1].get(\"year\")\n                alt_semester = years_data[1].get(\"semesters\")[0]\n\n            alt_stats_url = f\"{BASE_URL}/dashboard/statistics?academicYear={alt_academic_year}&semester={alt_semester}\"\n            alt_resp = requests.get(alt_stats_url, headers=headers, timeout=TIMEOUT)\n            assert alt_resp.status_code == 200, f\"Alternate dashboard statistics request failed: {alt_resp.text}\"\n            alt_stats = alt_resp.json()\n\n            # Check that statistics differ or at least are present and valid\n            for field in required_fields:\n                assert field in alt_stats, f\"Missing field in alt dashboard statistics: {field}\"\n                alt_value = alt_stats[field]\n                assert isinstance(alt_value, int) and alt_value >= 0, f\"Invalid alt value for {field}: {alt_value}\"\n            \n            # Ideally stats should be different when filters change, but if data is static, just confirm valid responses\n            # We do not assert inequality here to avoid test flakiness if data is same\n    except Exception as e:\n        raise AssertionError(f\"Error validating dashboard statistics filters: {e}\")\n\n    # Test filter interaction for one example filter:\n    # Assuming an endpoint to get filtered professors or submissions exists, simulate a filter change.\n    # Example: Filter by professorId (get list of professors first)\n    try:\n        profs_resp = requests.get(f\"{BASE_URL}/professors?academicYear={academic_year}&semester={semester}\", headers=headers, timeout=TIMEOUT)\n        assert profs_resp.status_code == 200, f\"Professors list request failed: {profs_resp.text}\"\n        profs = profs_resp.json()\n        if isinstance(profs, list) and len(profs) > 0:\n            professor_id = profs[0].get(\"id\")\n            # Now request submissions filtered by professorId\n            submissions_url = f\"{BASE_URL}/submissions/status?academicYear={academic_year}&semester={semester}&professorId={professor_id}\"\n            subs_resp = requests.get(submissions_url, headers=headers, timeout=TIMEOUT)\n            assert subs_resp.status_code == 200, f\"Submissions filtered request failed: {subs_resp.text}\"\n            subs_data = subs_resp.json()\n            assert isinstance(subs_data, list), \"Submission data should be a list\"\n    except Exception as e:\n        raise AssertionError(f\"Error testing dynamic filters for professors and submissions: {e}\")\n\n    # Further UI features mentioned (courses, file explorer, reports, navigation) are frontend-based and not covered by backend endpoint tests here.\n\ntest_hod_dashboard_statistics_and_filters()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 21, in test_hod_dashboard_statistics_and_filters\nAssertionError: Authentication failed: {\"success\":false,\"error\":{\"code\":\"RATE_LIMIT_EXCEEDED\",\"message\":\"Too many login attempts. Please wait before trying again.\",\"retryAfterSeconds\":3},\"timestamp\":1768310157162}\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 118, in <module>\n  File \"<string>\", line 26, in test_hod_dashboard_statistics_and_filters\nAssertionError: Authentication request failed: Authentication failed: {\"success\":false,\"error\":{\"code\":\"RATE_LIMIT_EXCEEDED\",\"message\":\"Too many login attempts. Please wait before trying again.\",\"retryAfterSeconds\":3},\"timestamp\":1768310157162}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.541Z",
    "modified": "2026-01-13T13:15:58.357Z"
  },
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "69a08740-f5f7-4bdf-80b0-3063a5caa033",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC003-test_professor_crud_operations_within_department",
    "description": "Validate CRUD operations for managing professors within the HOD's department, ensuring data integrity, proper validation, and that operations are scoped to the department and semester.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nHOD_EMAIL = \"hod.ce@hod.alquds.edu\"\nHOD_PASSWORD = \"Hh@#2021\"\n\nTIMEOUT = 30\n\n\ndef authenticate(email: str, password: str) -> str:\n    auth_url = \"http://localhost:8080/api/auth/login\"\n    try:\n        resp = requests.post(auth_url, json={\"email\": email, \"password\": password}, timeout=TIMEOUT)\n        resp.raise_for_status()\n        json_resp = resp.json()\n        token = json_resp.get(\"token\")\n        if not token:\n            token = json_resp.get(\"accessToken\")\n        assert token, \"Authentication token not found in response\"\n        return token\n    except Exception as e:\n        raise RuntimeError(f\"Authentication failed: {e}\")\n\n\ndef test_professor_crud_operations_within_department():\n    token = authenticate(HOD_EMAIL, HOD_PASSWORD)\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # 1. Get HOD department info (to scope professors)\n    dept_resp = requests.get(f\"{BASE_URL}/profile\", headers=headers, timeout=TIMEOUT)\n    dept_resp.raise_for_status()\n    profile_data = dept_resp.json()\n    department_id = profile_data.get(\"departmentId\")\n    assert department_id, \"Department ID not found in HOD profile\"\n\n    # Assume there is an academic year and semester selection endpoint or fixed values for test scope:\n    # For testing, assume params for semester scoping:\n    academic_year = profile_data.get(\"academicYear\", \"2025-2026\")\n    semester = profile_data.get(\"semester\", \"Fall\")\n\n    professor_id = None\n    professor_payload = {\n        \"name\": \"Test Professor \" + str(uuid.uuid4())[:8],\n        \"email\": f\"testprof{uuid.uuid4().hex[:6]}@faculty.alquds.edu\",\n        \"phone\": \"0599123456\",\n        \"departmentId\": department_id,\n        \"academicYear\": academic_year,\n        \"semester\": semester,\n        \"title\": \"Associate Professor\"\n    }\n\n    try:\n        # CREATE Professor\n        create_resp = requests.post(f\"{BASE_URL}/professors\", headers=headers, json=professor_payload, timeout=TIMEOUT)\n        create_resp.raise_for_status()\n        created_professor = create_resp.json()\n        professor_id = created_professor.get(\"id\")\n        assert professor_id, \"Created professor ID not returned\"\n        assert created_professor[\"email\"] == professor_payload[\"email\"]\n        assert created_professor[\"departmentId\"] == department_id\n\n        # READ - Get professor by ID and verify fields and scoping\n        get_resp = requests.get(f\"{BASE_URL}/professors/{professor_id}\", headers=headers, timeout=TIMEOUT)\n        get_resp.raise_for_status()\n        professor_data = get_resp.json()\n        assert professor_data[\"id\"] == professor_id\n        assert professor_data[\"departmentId\"] == department_id\n        assert professor_data[\"academicYear\"] == academic_year\n        assert professor_data[\"semester\"] == semester\n\n        # UPDATE professor - modify phone and title\n        updated_payload = {\n            \"phone\": \"0599765432\",\n            \"title\": \"Professor\"\n        }\n        update_resp = requests.put(f\"{BASE_URL}/professors/{professor_id}\", headers=headers, json=updated_payload, timeout=TIMEOUT)\n        update_resp.raise_for_status()\n        updated_professor = update_resp.json()\n        assert updated_professor[\"phone\"] == updated_payload[\"phone\"]\n        assert updated_professor[\"title\"] == updated_payload[\"title\"]\n\n        # LIST professors in department and semester - Verify the created professor appears\n        params = {\"departmentId\": department_id, \"academicYear\": academic_year, \"semester\": semester}\n        list_resp = requests.get(f\"{BASE_URL}/professors\", headers=headers, params=params, timeout=TIMEOUT)\n        list_resp.raise_for_status()\n        prof_list = list_resp.json()\n        assert any(p[\"id\"] == professor_id for p in prof_list), \"Created professor not found in filtered professor list\"\n\n        # VALIDATION - try creating professor with duplicate email - should fail\n        dup_resp = requests.post(f\"{BASE_URL}/professors\", headers=headers, json=professor_payload, timeout=TIMEOUT)\n        assert dup_resp.status_code == 400 or dup_resp.status_code == 409, \"Duplicate professor creation should fail\"\n\n    finally:\n        # CLEANUP - DELETE professor\n        if professor_id:\n            del_resp = requests.delete(f\"{BASE_URL}/professors/{professor_id}\", headers=headers, timeout=TIMEOUT)\n            # Deletion might be soft delete; accept 200 or 204 or 202\n            assert del_resp.status_code in [200, 202, 204], \"Professor deletion failed\"\n\n\ntest_professor_crud_operations_within_department()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 15, in authenticate\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 429 Client Error: Too Many Requests for url: http://localhost:8080/api/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 105, in <module>\n  File \"<string>\", line 27, in test_professor_crud_operations_within_department\n  File \"<string>\", line 23, in authenticate\nRuntimeError: Authentication failed: 429 Client Error: Too Many Requests for url: http://localhost:8080/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.546Z",
    "modified": "2026-01-13T13:15:51.341Z"
  },
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "fae19be3-7b72-42e0-8dd6-c7527f62eb60",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC004-test_submission_status_filtering_and_retrieval",
    "description": "Check that submission status API correctly filters and returns data based on course, document type, and submission status for professors in the department.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nUSERNAME = \"hod.ce@hod.alquds.edu\"\nPASSWORD = \"Hh@#2021\"\nTIMEOUT = 30\n\ndef test_submission_status_filtering_and_retrieval():\n    session = requests.Session()\n    token = None\n    try:\n        # Authenticate and obtain JWT token\n        login_resp = session.post(\n            f\"{BASE_URL}/auth/login\",\n            json={\"username\": USERNAME, \"password\": PASSWORD},\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data, \"JWT token not found in login response\"\n        token = login_data[\"token\"]\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\"\n        }\n\n        # Prepare filter parameters for submission status\n        # We need to test filtering by course, document type, and submission status\n        # Since no specific values are given, fetch possible courses and document types first to get valid filter values\n\n        # 1. Retrieve courses for the HOD's department\n        courses_resp = session.get(f\"{BASE_URL}/courses\", headers=headers, timeout=TIMEOUT)\n        assert courses_resp.status_code == 200, f\"Getting courses failed: {courses_resp.text}\"\n        courses = courses_resp.json()\n        assert isinstance(courses, list), \"Courses response is not a list\"\n\n        if not courses:\n            raise AssertionError(\"No courses found for department to use as filter\")\n\n        course_id = courses[0].get(\"id\")\n        assert course_id is not None, \"Course ID missing in course data\"\n\n        # 2. Retrieve document types for filtering - assuming API endpoint exists for document types\n        doc_types_resp = session.get(f\"{BASE_URL}/document-types\", headers=headers, timeout=TIMEOUT)\n        assert doc_types_resp.status_code == 200, f\"Getting document types failed: {doc_types_resp.text}\"\n        document_types = doc_types_resp.json()\n        assert isinstance(document_types, list), \"Document types response is not a list\"\n\n        if not document_types:\n            raise AssertionError(\"No document types found to use as filter\")\n\n        document_type_id = document_types[0].get(\"id\")\n        assert document_type_id is not None, \"Document type ID missing in document type data\"\n\n        # 3. Possible submission statuses to filter by, assuming these are the values accepted\n        submission_statuses = [\"pending\", \"approved\", \"rejected\"]  # typical statuses, adjust if API docs specify differently\n        submission_status = submission_statuses[0]\n\n        # Prepare filter payload or query params - guessing API spec based on usual patterns\n        params = {\n            \"courseId\": course_id,\n            \"documentTypeId\": document_type_id,\n            \"submissionStatus\": submission_status\n        }\n\n        # Retrieve filtered submission status data\n        submissions_resp = session.get(f\"{BASE_URL}/submission-status\", headers=headers, params=params, timeout=TIMEOUT)\n        assert submissions_resp.status_code == 200, f\"Submission status filtering request failed: {submissions_resp.text}\"\n        submissions_data = submissions_resp.json()\n        assert isinstance(submissions_data, list), \"Submission status response is not a list\"\n\n        # Validate that all returned submissions match the filters applied\n        for submission in submissions_data:\n            # Assuming submission contains keys courseId, documentTypeId, and status keys to verify filtering\n            assert submission.get(\"courseId\") == course_id, f\"Submission courseId mismatch: expected {course_id}, got {submission.get('courseId')}\"\n            assert submission.get(\"documentTypeId\") == document_type_id, f\"Submission documentTypeId mismatch: expected {document_type_id}, got {submission.get('documentTypeId')}\"\n            assert submission.get(\"status\") == submission_status, f\"Submission status mismatch: expected {submission_status}, got {submission.get('status')}\"\n\n    finally:\n        session.close()\n\ntest_submission_status_filtering_and_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 83, in <module>\n  File \"<string>\", line 18, in test_submission_status_filtering_and_retrieval\nAssertionError: Login failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.551Z",
    "modified": "2026-01-13T13:15:49.837Z"
  },
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "ce07549a-a4e7-41e8-b511-34a0663f03da",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC005-test_document_request_creation_view_and_deletion",
    "description": "Verify the creation, viewing, and deletion of document requests for professors in the HOD's department, ensuring proper validation and department scoping.",
    "code": "import requests\nimport json\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nLOGIN_URL = f\"{BASE_URL}/auth/login\"\nDOCUMENT_REQUEST_URL = f\"{BASE_URL}/document-requests\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\nhod_credentials = {\n    \"email\": \"hod.ce@hod.alquds.edu\",\n    \"password\": \"Hh@#2021\"\n}\n\ndef test_document_request_creation_view_and_deletion():\n    session = requests.Session()\n    try:\n        # Authenticate to get JWT token\n        resp = session.post(LOGIN_URL, json=hod_credentials, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Login failed with status code {resp.status_code}\"\n        token = resp.json().get(\"token\")\n        assert token, \"JWT token not found in login response\"\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n        # Step 1: Create a new document request for a professor in the HOD's department\n        # As no explicit payload schema is provided, assume minimal required fields: professorId, documentType, dueDate\n        # First, find a professor in the department to request document for\n        prof_resp = session.get(f\"{BASE_URL}/professors\", headers=auth_headers, timeout=TIMEOUT)\n        assert prof_resp.status_code == 200, f\"Failed to fetch professors with status code {prof_resp.status_code}\"\n        professors = prof_resp.json()\n        assert isinstance(professors, list) and len(professors) > 0, \"No professors found in HOD department\"\n        professor_id = professors[0].get(\"id\")\n        assert professor_id, \"Professor id missing\"\n\n        # Prepare the document request payload\n        import datetime\n        due_date = (datetime.datetime.now() + datetime.timedelta(days=30)).strftime(\"%Y-%m-%d\")\n\n        create_payload = {\n            \"professorId\": professor_id,\n            \"documentType\": \"Transcript\",\n            \"dueDate\": due_date,\n            \"notes\": \"Test document request creation\"\n        }\n\n        create_resp = session.post(DOCUMENT_REQUEST_URL, json=create_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert create_resp.status_code == 201, f\"Document request creation failed with status {create_resp.status_code}\"\n        created_req = create_resp.json()\n        request_id = created_req.get(\"id\")\n        assert request_id, \"Created document request ID missing\"\n\n        # Step 2: View the created document request and validate fields\n        get_resp = session.get(f\"{DOCUMENT_REQUEST_URL}/{request_id}\", headers=auth_headers, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Failed to get created document request, status {get_resp.status_code}\"\n        fetched_req = get_resp.json()\n        assert fetched_req.get(\"id\") == request_id, \"Fetched document request ID mismatch\"\n        assert fetched_req.get(\"professorId\") == professor_id, \"Professor ID mismatch in fetched document request\"\n        assert fetched_req.get(\"documentType\") == create_payload[\"documentType\"], \"Document type mismatch\"\n        assert fetched_req.get(\"dueDate\") == create_payload[\"dueDate\"], \"Due date mismatch\"\n        assert fetched_req.get(\"notes\") == create_payload[\"notes\"], \"Notes mismatch\"\n\n        # Step 3: List all document requests for the department, confirm the created request is present\n        list_resp = session.get(DOCUMENT_REQUEST_URL, headers=auth_headers, timeout=TIMEOUT)\n        assert list_resp.status_code == 200, f\"Failed to list document requests, status {list_resp.status_code}\"\n        requests_list = list_resp.json()\n        assert any(req.get(\"id\") == request_id for req in requests_list), \"Created document request not found in listing\"\n\n    finally:\n        # Clean up - delete the created document request\n        if 'request_id' in locals():\n            del_resp = session.delete(f\"{DOCUMENT_REQUEST_URL}/{request_id}\", headers=auth_headers, timeout=TIMEOUT)\n            assert del_resp.status_code in (200, 204), f\"Failed to delete document request with status {del_resp.status_code}\"\n\ntest_document_request_creation_view_and_deletion()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 76, in <module>\n  File \"<string>\", line 20, in test_document_request_creation_view_and_deletion\nAssertionError: Login failed with status code 403\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.557Z",
    "modified": "2026-01-13T13:15:32.178Z"
  },
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "9878749d-b36e-4bc4-9974-ea17fd0a521e",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC006-test_report_generation_and_pdf_export",
    "description": "Test the report generation API for professor submissions with various filter combinations and verify that the exported PDF report is correctly generated and downloadable.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nLOGIN_URL = f\"{BASE_URL}/auth/login\"\nREPORTS_GENERATE_URL = f\"{BASE_URL}/reports/professor-submissions\"\nREPORTS_EXPORT_PDF_URL = f\"{BASE_URL}/reports/professor-submissions/export\"\n\nHOD_EMAIL = \"hod.ce@hod.alquds.edu\"\nHOD_PASSWORD = \"Hh@#2021\"\nTIMEOUT = 30\n\n\ndef test_report_generation_and_pdf_export():\n    # Authenticate and get JWT token\n    auth_payload = {\"email\": HOD_EMAIL, \"password\": HOD_PASSWORD}\n    try:\n        auth_resp = requests.post(LOGIN_URL, json=auth_payload, timeout=TIMEOUT)\n        assert auth_resp.status_code == 200, f\"Login failed: {auth_resp.text}\"\n        token = auth_resp.json().get(\"token\")\n        assert token, \"JWT token not found in login response\"\n    except RequestException as e:\n        assert False, f\"Login request failed with exception: {e}\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Define various filter combinations to test report generation\n    filter_combinations = [\n        {},  # No filters - default\n        {\"academicYear\": \"2024/2025\"},\n        {\"academicYear\": \"2024/2025\", \"semester\": \"1\"},\n        {\"academicYear\": \"2024/2025\", \"semester\": \"2\", \"departmentId\": 1},\n        {\"semester\": \"1\"},\n        {\"departmentId\": 1},\n        {\"academicYear\": \"2023/2024\", \"semester\": \"2\"},\n    ]\n\n    for filters in filter_combinations:\n        # Step 1: Generate report data with filters\n        try:\n            resp = requests.get(REPORTS_GENERATE_URL, headers=headers, params=filters, timeout=TIMEOUT)\n        except RequestException as e:\n            assert False, f\"Report generation request failed with exception: {e}\"\n\n        assert resp.status_code == 200, f\"Report generation failed with filters {filters}, response: {resp.text}\"\n        data = resp.json()\n        assert isinstance(data, dict), f\"Expected JSON object for report data, got: {data}\"\n        # Validate essential keys in report data if present\n        assert \"report\" in data or \"submissions\" in data or \"summary\" in data, f\"Report data missing expected keys for filters {filters}\"\n\n        # Step 2: Export report as PDF (with same filters)\n        try:\n            resp_pdf = requests.get(REPORTS_EXPORT_PDF_URL, headers=headers, params=filters, timeout=TIMEOUT)\n        except RequestException as e:\n            assert False, f\"PDF export request failed with exception: {e}\"\n\n        assert resp_pdf.status_code == 200, f\"PDF export failed with filters {filters}, response: {resp_pdf.text}\"\n        content_type = resp_pdf.headers.get(\"Content-Type\", \"\")\n        content_disp = resp_pdf.headers.get(\"Content-Disposition\", \"\")\n\n        # Validate PDF mime type and content disposition headers\n        assert \"application/pdf\" in content_type.lower(), f\"Invalid Content-Type for PDF export: {content_type}\"\n        assert \"attachment\" in content_disp.lower() and \".pdf\" in content_disp.lower(), f\"Content-Disposition header invalid or missing for PDF export: {content_disp}\"\n\n        # Validate PDF content is non-empty\n        content_length = len(resp_pdf.content)\n        assert content_length > 100, f\"PDF export content too small, length: {content_length}\"\n\n    print(\"All report generation and PDF export tests passed.\")\n\n\ntest_report_generation_and_pdf_export()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 74, in <module>\n  File \"<string>\", line 19, in test_report_generation_and_pdf_export\nAssertionError: Login failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.562Z",
    "modified": "2026-01-13T13:15:31.088Z"
  },
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "65c05e68-5a07-48ad-9734-ca2a0ab79d12",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC007-test_file_explorer_department_scoped_access",
    "description": "Ensure that the file explorer API allows browsing and downloading files only within the HOD's department archive and enforces department-scoped access control.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nAUTH_URL = f\"{BASE_URL}/auth/login\"\nFILE_EXPLORER_BROWSE_URL = f\"{BASE_URL}/file-explorer/browse\"\nFILE_EXPLORER_DOWNLOAD_URL = f\"{BASE_URL}/file-explorer/download\"\n\nHOD_EMAIL = \"hod.ce@hod.alquds.edu\"\nHOD_PASSWORD = \"Hh@#2021\"\nTIMEOUT = 30\n\ndef test_file_explorer_department_scoped_access():\n    session = requests.Session()\n    try:\n        # Authenticate to get JWT token\n        auth_payload = {\"username\": HOD_EMAIL, \"password\": HOD_PASSWORD}\n        auth_resp = session.post(AUTH_URL, json=auth_payload, timeout=TIMEOUT)\n        assert auth_resp.status_code == 200, f\"Authentication failed: {auth_resp.text}\"\n        auth_data = auth_resp.json()\n        token = auth_data.get(\"token\") or auth_data.get(\"accessToken\")\n        assert token, \"JWT token missing in auth response\"\n\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # 1. Browse files within HOD department archive - expect success\n        browse_params = {\"path\": \"/\"}  # Root of department archive\n        browse_resp = session.get(FILE_EXPLORER_BROWSE_URL, headers=headers, params=browse_params, timeout=TIMEOUT)\n        assert browse_resp.status_code == 200, f\"Failed to browse department files: {browse_resp.text}\"\n        browse_data = browse_resp.json()\n        assert isinstance(browse_data, dict) and \"files\" in browse_data, \"Invalid browse response structure\"\n        files_list = browse_data.get(\"files\", [])\n        assert isinstance(files_list, list), \"Files list should be a list\"\n\n        if files_list:\n            file_item = files_list[0]\n            file_path = file_item.get(\"path\") or file_item.get(\"name\")\n            assert file_path, \"File path/name missing\"\n\n            # 2. Download the file within department archive - expect success\n            download_params = {\"path\": file_path}\n            download_resp = session.get(FILE_EXPLORER_DOWNLOAD_URL, headers=headers, params=download_params, timeout=TIMEOUT)\n            assert download_resp.status_code == 200, f\"Failed to download file within department: {download_resp.text}\"\n            content_type = download_resp.headers.get(\"Content-Type\", \"\")\n            assert content_type.startswith(\"application/\") or content_type.startswith(\"text/\") or content_type == \"application/octet-stream\", \\\n                f\"Unexpected content type for downloaded file: {content_type}\"\n            assert download_resp.content, \"Downloaded file content is empty\"\n\n        # 3. Attempt browsing files outside the department archive - expect failure or empty\n        invalid_browse_params = {\"path\": \"../../\"}\n        invalid_browse_resp = session.get(FILE_EXPLORER_BROWSE_URL, headers=headers, params=invalid_browse_params, timeout=TIMEOUT)\n        assert invalid_browse_resp.status_code in (400,403,404) or (invalid_browse_resp.status_code == 200 and not invalid_browse_resp.json().get(\"files\")), \\\n            \"Browsing outside department scope was not blocked\"\n\n        # 4. Attempt to download a file outside department scope - expect error response\n        invalid_download_params = {\"path\": \"../../etc/passwd\"}\n        invalid_download_resp = session.get(FILE_EXPLORER_DOWNLOAD_URL, headers=headers, params=invalid_download_params, timeout=TIMEOUT)\n        assert invalid_download_resp.status_code in (400,403,404), \"Download outside department scope was not blocked\"\n\n    finally:\n        session.close()\n\ntest_file_explorer_department_scoped_access()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 18, in test_file_explorer_department_scoped_access\nAssertionError: Authentication failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.567Z",
    "modified": "2026-01-13T13:16:10.640Z"
  },
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "5b0f4783-dc42-411f-9697-aad26ace845c",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC008-test_notification_retrieval_and_management",
    "description": "Validate that notifications related to department submissions are correctly retrieved and can be managed (e.g., marked as read) through the API.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nAUTH_URL = \"http://localhost:8080/api/auth/login\"\nHOD_EMAIL = \"hod.ce@hod.alquds.edu\"\nHOD_PASSWORD = \"Hh@#2021\"\nTIMEOUT = 30\n\n\ndef test_notification_retrieval_and_management():\n    # Authenticate and get JWT token\n    auth_payload = {\"email\": HOD_EMAIL, \"password\": HOD_PASSWORD}\n    token = None\n    headers = {\"Content-Type\": \"application/json\"}\n\n    try:\n        auth_resp = requests.post(AUTH_URL, json=auth_payload, headers=headers, timeout=TIMEOUT)\n        assert auth_resp.status_code == 200, f\"Authentication failed: {auth_resp.text}\"\n        token = auth_resp.json().get(\"accessToken\")\n        assert token, \"No token received after authentication\"\n\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Accept\": \"application/json\"\n        }\n\n        # Retrieve notifications related to department submissions\n        notif_resp = requests.get(f\"{BASE_URL}/notifications\", headers=auth_headers, timeout=TIMEOUT)\n        assert notif_resp.status_code == 200, f\"Failed to get notifications: {notif_resp.text}\"\n        notifications = notif_resp.json()\n        assert isinstance(notifications, list), \"Notifications response is not a list\"\n\n        if not notifications:\n            # No notifications, create a dummy submission to generate a notification or skip\n            # Since no API schema provided for creating submissions or triggering notifications,\n            # we just return test success as retrieval did not fail\n            print(\"No notifications present to manage.\")\n            return\n\n        # Pick one notification to mark as read\n        notification = None\n        for n in notifications:\n            # Target notifications related to department submissions based on known keys\n            # Assuming notifications have 'id' and 'type' fields and 'read' status\n            if \"submission\" in n.get(\"type\", \"\").lower() or \"submission\" in n.get(\"title\", \"\").lower():\n                notification = n\n                break\n        if not notification:\n            notification = notifications[0]\n\n        notif_id = notification.get(\"id\")\n        assert notif_id, \"Notification ID missing in notification item\"\n\n        # Check initial read status, if available\n        initial_read_status = notification.get(\"read\")\n        # Toggle read status: if unread mark read, else mark unread\n        new_read_status = not initial_read_status if initial_read_status is not None else True\n\n        mark_read_payload = {\"read\": new_read_status}\n\n        # Mark the notification as read/unread\n        mark_read_resp = requests.put(f\"{BASE_URL}/notifications/{notif_id}/read\", json=mark_read_payload,\n                                      headers=auth_headers, timeout=TIMEOUT)\n        assert mark_read_resp.status_code == 200, f\"Failed to update notification read status: {mark_read_resp.text}\"\n        updated_notification = mark_read_resp.json()\n        assert updated_notification.get(\"id\") == notif_id, \"Updated notification ID mismatch\"\n        assert updated_notification.get(\"read\") == new_read_status, \"Notification read status not updated\"\n\n        # Optionally, retrieve notifications again and verify the update persisted\n        notif_resp2 = requests.get(f\"{BASE_URL}/notifications\", headers=auth_headers, timeout=TIMEOUT)\n        assert notif_resp2.status_code == 200, \"Failed to re-fetch notifications\"\n        notifications_after_update = notif_resp2.json()\n        found_updated = False\n        for n in notifications_after_update:\n            if n.get(\"id\") == notif_id:\n                found_updated = True\n                assert n.get(\"read\") == new_read_status, \"Read status did not persist after update\"\n                break\n        assert found_updated, \"Updated notification not found after modification\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n\ntest_notification_retrieval_and_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 85, in <module>\n  File \"<string>\", line 18, in test_notification_retrieval_and_management\nAssertionError: Authentication failed: {\"success\":false,\"error\":{\"code\":\"RATE_LIMIT_EXCEEDED\",\"message\":\"Too many login attempts. Please wait before trying again.\",\"retryAfterSeconds\":11},\"timestamp\":1768310149479}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.572Z",
    "modified": "2026-01-13T13:15:50.579Z"
  },
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "0d725ce2-d3e7-46be-b697-1f345bf319ed",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC009-test_semester_based_operation_scoping",
    "description": "Verify that all operations and data retrievals are correctly scoped to the selected academic year and semester, and that changing these parameters updates the data accordingly.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nAUTH_ENDPOINT = f\"{BASE_URL}/auth/login\"\nDASHBOARD_ENDPOINT = f\"{BASE_URL}/dashboard\"\nPROFESSORS_ENDPOINT = f\"{BASE_URL}/professors\"\nREPORTS_ENDPOINT = f\"{BASE_URL}/reports\"\nFILE_EXPLORER_ENDPOINT = f\"{BASE_URL}/files\"\nNOTIFICATIONS_ENDPOINT = f\"{BASE_URL}/notifications\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\nHOD_EMAIL = \"hod.ce@hod.alquds.edu\"\nHOD_PASSWORD = \"Hh@#2021\"\n\ndef test_semester_based_operation_scoping():\n    # Authenticate and obtain JWT token\n    login_payload = {\"email\": HOD_EMAIL, \"password\": HOD_PASSWORD}\n    token = None\n    try:\n        auth_resp = requests.post(\n            AUTH_ENDPOINT,\n            json=login_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert auth_resp.status_code == 200, f\"Login failed: {auth_resp.text}\"\n        auth_data = auth_resp.json()\n        token = auth_data.get(\"token\")\n        assert token, \"No token received in login response\"\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n        # Step 1: Retrieve dashboard data for initial academic year and semester\n        params1 = {\"academicYear\": \"2023-2024\", \"semester\": \"1\"}\n        dash_resp1 = requests.get(\n            DASHBOARD_ENDPOINT, headers=auth_headers, params=params1, timeout=TIMEOUT\n        )\n        assert dash_resp1.status_code == 200, f\"Dashboard request failed: {dash_resp1.text}\"\n        dashboard_data_1 = dash_resp1.json()\n\n        # Step 2: Retrieve professor list scoped to initial academic year and semester\n        prof_resp1 = requests.get(\n            PROFESSORS_ENDPOINT, headers=auth_headers, params=params1, timeout=TIMEOUT\n        )\n        assert prof_resp1.status_code == 200, f\"Professors request failed: {prof_resp1.text}\"\n        professors_1 = prof_resp1.json()\n\n        # Step 3: Retrieve reports scoped to initial academic year and semester\n        reports_resp1 = requests.get(\n            REPORTS_ENDPOINT, headers=auth_headers, params=params1, timeout=TIMEOUT\n        )\n        assert reports_resp1.status_code == 200, f\"Reports request failed: {reports_resp1.text}\"\n        reports_1 = reports_resp1.json()\n\n        # Step 4: Retrieve list of files for initial academic year and semester\n        files_resp1 = requests.get(\n            FILE_EXPLORER_ENDPOINT, headers=auth_headers, params=params1, timeout=TIMEOUT\n        )\n        assert files_resp1.status_code == 200, f\"Files request failed: {files_resp1.text}\"\n        files_1 = files_resp1.json()\n\n        # Step 5: Retrieve notifications scoped to initial academic year and semester\n        notifications_resp1 = requests.get(\n            NOTIFICATIONS_ENDPOINT, headers=auth_headers, params=params1, timeout=TIMEOUT\n        )\n        assert notifications_resp1.status_code == 200, f\"Notifications request failed: {notifications_resp1.text}\"\n        notifications_1 = notifications_resp1.json()\n\n        # Change the academic year and semester parameters\n        params2 = {\"academicYear\": \"2022-2023\", \"semester\": \"2\"}\n\n        dash_resp2 = requests.get(\n            DASHBOARD_ENDPOINT, headers=auth_headers, params=params2, timeout=TIMEOUT\n        )\n        assert dash_resp2.status_code == 200, f\"Dashboard request failed (semester change): {dash_resp2.text}\"\n        dashboard_data_2 = dash_resp2.json()\n\n        prof_resp2 = requests.get(\n            PROFESSORS_ENDPOINT, headers=auth_headers, params=params2, timeout=TIMEOUT\n        )\n        assert prof_resp2.status_code == 200, f\"Professors request failed (semester change): {prof_resp2.text}\"\n        professors_2 = prof_resp2.json()\n\n        reports_resp2 = requests.get(\n            REPORTS_ENDPOINT, headers=auth_headers, params=params2, timeout=TIMEOUT\n        )\n        assert reports_resp2.status_code == 200, f\"Reports request failed (semester change): {reports_resp2.text}\"\n        reports_2 = reports_resp2.json()\n\n        files_resp2 = requests.get(\n            FILE_EXPLORER_ENDPOINT, headers=auth_headers, params=params2, timeout=TIMEOUT\n        )\n        assert files_resp2.status_code == 200, f\"Files request failed (semester change): {files_resp2.text}\"\n        files_2 = files_resp2.json()\n\n        notifications_resp2 = requests.get(\n            NOTIFICATIONS_ENDPOINT, headers=auth_headers, params=params2, timeout=TIMEOUT\n        )\n        assert notifications_resp2.status_code == 200, f\"Notifications request failed (semester change): {notifications_resp2.text}\"\n        notifications_2 = notifications_resp2.json()\n\n        # Validate that data between the two semesters differs, indicating correct scoping and update\n        # For dashboard overview, expect some change in summary stats\n        assert dashboard_data_1 != dashboard_data_2, \"Dashboard data should differ between semesters\"\n\n        # Professors list might differ due to active/assigned semester filtering\n        assert professors_1 != professors_2 or isinstance(professors_1, list), \"Professors data should update per semester\"\n\n        # Reports data should differ to reflect semester scoped reports\n        assert reports_1 != reports_2, \"Reports data should differ between semesters\"\n\n        # Files (archive content) should differ or at least be filtered by semester\n        assert files_1 != files_2 or isinstance(files_1, list), \"File explorer data should update per semester\"\n\n        # Notifications should reflect semester scoped submissions\n        assert notifications_1 != notifications_2 or isinstance(notifications_1, list), \"Notifications should differ between semesters\"\n\n    except (requests.RequestException, AssertionError) as ex:\n        raise AssertionError(f\"Test failed: {ex}\")\n        \n\ntest_semester_based_operation_scoping()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 27, in test_semester_based_operation_scoping\nAssertionError: Login failed: \n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 124, in <module>\n  File \"<string>\", line 121, in test_semester_based_operation_scoping\nAssertionError: Test failed: Login failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.577Z",
    "modified": "2026-01-13T13:15:55.443Z"
  },
  {
    "projectId": "b24de6fe-9059-4ad4-bf44-fe6e04618daf",
    "testId": "1298d934-8765-4a89-aa90-6b34faea0d89",
    "userId": "5468f4d8-3031-70dc-f499-d71b76afac0b",
    "title": "TC010-test_error_handling_and_user_feedback",
    "description": "Check that API endpoints provide appropriate error messages and status codes for invalid inputs, unauthorized access, and other failure scenarios, supporting frontend user feedback mechanisms.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL = \"http://localhost:8080/api/hod\"\nAUTH_URL = \"http://localhost:8080/api/auth/login\"\nHOD_EMAIL = \"hod.ce@hod.alquds.edu\"\nHOD_PASSWORD = \"Hh@#2021\"\nTIMEOUT = 30\n\n\ndef authenticate():\n    try:\n        resp = requests.post(\n            AUTH_URL,\n            json={\"email\": HOD_EMAIL, \"password\": HOD_PASSWORD},\n            timeout=TIMEOUT,\n        )\n        resp.raise_for_status()\n        data = resp.json()\n        token = data.get(\"token\")\n        assert token, \"Authentication token not received\"\n        return token\n    except (RequestException, AssertionError) as e:\n        raise Exception(f\"Authentication failed: {e}\")\n\n\ndef test_error_handling_and_user_feedback():\n    token = authenticate()\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Helper function to assert error response structure and status\n    def assert_error(resp, expected_status, expected_message_contains=None):\n        assert resp.status_code == expected_status, f\"Expected status {expected_status}, got {resp.status_code}\"\n        try:\n            err_json = resp.json()\n        except Exception:\n            raise AssertionError(\"Response is not in JSON format\")\n        assert \"error\" in err_json or \"message\" in err_json, \"Error message missing in response\"\n        if expected_message_contains:\n            msg = err_json.get(\"error\") or err_json.get(\"message\") or \"\"\n            assert expected_message_contains.lower() in msg.lower(), f\"Expected message to contain '{expected_message_contains}', got '{msg}'\"\n\n    # 1. Unauthorized access: Call protected endpoint without token\n    response = requests.get(f\"{BASE_URL}/dashboard-overview\", timeout=TIMEOUT)\n    assert_error(response, 401, \"Unauthorized\")\n\n    # 2. Invalid token: call protected endpoint with invalid token\n    invalid_headers = {\"Authorization\": \"Bearer invalid.token.value\"}\n    response = requests.get(f\"{BASE_URL}/dashboard-overview\", headers=invalid_headers, timeout=TIMEOUT)\n    assert_error(response, 401, \"Unauthorized\")\n\n    # 3. Access with insufficient role (simulate by using a malformed token or invalid role token if possible)\n    # Since we only have HOD token, simulate by calling user-management with malformed token\n    response = requests.get(f\"{BASE_URL}/professors\", headers=invalid_headers, timeout=TIMEOUT)\n    assert_error(response, 401, \"Unauthorized\")\n\n    # 4. Invalid input error: Create professor with invalid payload (missing required fields)\n    invalid_prof_payload = {\"email\": \"invalid-email-format\", \"name\": \"\", \"departmentId\": -1}  # invalid email, empty name, invalid deptId\n    response = requests.post(f\"{BASE_URL}/professors\", headers=headers, json=invalid_prof_payload, timeout=TIMEOUT)\n    assert_error(response, 400, \"validation\")\n\n    # 5. Delete non-existing professor (invalid UUID)\n    fake_professor_id = \"00000000-0000-0000-0000-000000000000\"\n    response = requests.delete(f\"{BASE_URL}/professors/{fake_professor_id}\", headers=headers, timeout=TIMEOUT)\n    assert_error(response, 404, \"not found\")\n\n    # 6. Prevent deletion due to dependencies: Try to delete a department with active professors. We must get one department with dependencies first.\n    # Get departments and pick one. If no departments, skip.\n    resp_depts = requests.get(f\"{BASE_URL}/departments\", headers=headers, timeout=TIMEOUT)\n    if resp_depts.status_code == 200 and resp_depts.json():\n        departments = resp_depts.json()\n        dep_with_dependency = None\n        for dep in departments:\n            dep_id = dep.get(\"id\")\n            # check if department has professors\n            prof_resp = requests.get(f\"{BASE_URL}/professors?departmentId={dep_id}\", headers=headers, timeout=TIMEOUT)\n            if prof_resp.status_code == 200 and prof_resp.json():\n                dep_with_dependency = dep_id\n                break\n        if dep_with_dependency:\n            del_resp = requests.delete(f\"{BASE_URL}/departments/{dep_with_dependency}\", headers=headers, timeout=TIMEOUT)\n            assert_error(del_resp, 409, \"conflict\")\n\n    # 7. Invalid query parameter: Request reports with invalid filter parameter (wrong type)\n    invalid_query_params = {\"academicYear\": \"not-a-year\", \"semester\": \"invalid-semester\"}\n    response = requests.get(f\"{BASE_URL}/reports\", headers=headers, params=invalid_query_params, timeout=TIMEOUT)\n    assert_error(response, 400, \"invalid\")\n\n    # 8. Access file explorer with unauthorized department id (simulate by using non-existing or wrong department id)\n    # Since we cannot guarantee department IDs, use a random id\n    forbidden_dep_id = \"99999999-9999-9999-9999-999999999999\"\n    response = requests.get(f\"{BASE_URL}/file-explorer/{forbidden_dep_id}\", headers=headers, timeout=TIMEOUT)\n    # Expected 403 Forbidden or 404 Not Found depending on implementation\n    assert response.status_code in (403, 404)\n\n    # 9. Submission status with invalid filter values (e.g., invalid course id)\n    response = requests.get(f\"{BASE_URL}/submission-status\", headers=headers, params={\"courseId\": \"invalid-course-id\"}, timeout=TIMEOUT)\n    assert_error(response, 400, \"invalid\")\n\n    # 10. Report export with missing required parameters\n    response = requests.get(f\"{BASE_URL}/reports/export\", headers=headers, timeout=TIMEOUT)\n    assert_error(response, 400, \"missing\")\n\n    # 11. Test expired JWT (simulate by tampering token expiry time if possible)\n    # We cannot generate expired token here; simulate by using malformed but well-formed token structure\n    expired_token = token[:-5] + \"abcde\"  # corrupted token\n    expired_headers = {\"Authorization\": f\"Bearer {expired_token}\"}\n    response = requests.get(f\"{BASE_URL}/dashboard-overview\", headers=expired_headers, timeout=TIMEOUT)\n    assert_error(response, 401, \"expired\")\n\n    # 12. Invalid method: POST on GET-only endpoint (reports tab overview)\n    response = requests.post(f\"{BASE_URL}/dashboard-overview\", headers=headers, timeout=TIMEOUT)\n    assert response.status_code in (405, 404)\n\n    # 13. Partial input for required fields in professor creation (e.g., missing required fields)\n    partial_payload = {\"email\": \"professor@university.edu\"}  # missing other required fields\n    response = requests.post(f\"{BASE_URL}/professors\", headers=headers, json=partial_payload, timeout=TIMEOUT)\n    assert_error(response, 400, \"required\")\n\n    # 14. Filter professors with invalid filter combination (e.g., page with negative number)\n    response = requests.get(f\"{BASE_URL}/professors\", headers=headers, params={\"page\": -1}, timeout=TIMEOUT)\n    assert_error(response, 400, \"invalid\")\n\n    # 15. Validate notification management error on invalid notification id\n    invalid_notify_id = \"00000000-0000-0000-0000-000000000000\"\n    resp_mark_read = requests.put(f\"{BASE_URL}/notifications/{invalid_notify_id}/mark-read\", headers=headers, timeout=TIMEOUT)\n    assert_error(resp_mark_read, 404, \"not found\")\n\n\ntest_error_handling_and_user_feedback()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 18, in authenticate\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 429 Client Error: Too Many Requests for url: http://localhost:8080/api/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 130, in <module>\n  File \"<string>\", line 28, in test_error_handling_and_user_feedback\n  File \"<string>\", line 24, in authenticate\nException: Authentication failed: 429 Client Error: Too Many Requests for url: http://localhost:8080/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T13:14:40.582Z",
    "modified": "2026-01-13T13:15:54.438Z"
  }
]
