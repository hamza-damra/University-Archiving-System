# Deprecation Strategy

## Overview

This document explains the deprecation strategy used for the legacy request-based system as part of the migration to the semester-based file exploration system.

**Date:** November 18, 2025  
**Version:** 2.0

---

## Deprecation Approach

### 1. Marking Components as Deprecated

All legacy components are marked with the `@Deprecated` annotation:

```java
@Deprecated(since = "2.0", forRemoval = false)
```

**Parameters:**
- `since = "2.0"`: Indicates the version when deprecation started
- `forRemoval = false`: Indicates these components will NOT be removed (kept for historical data and rollback)

### 2. Comprehensive Documentation

Each deprecated component includes JavaDoc comments explaining:
- Why it's deprecated
- What replaces it in the new system
- Why it's being kept (historical data, rollback, migration)
- References to replacement components

**Example:**
```java
/**
 * LEGACY ENTITY - ARCHIVED
 * 
 * This entity is part of the old request-based document system and has been replaced
 * by the new semester-based structure using CourseAssignment and RequiredDocumentType entities.
 * 
 * Replacement entities:
 * - CourseAssignment: Links professors to courses within semesters
 * - RequiredDocumentType: Defines required document types per course
 * 
 * This entity is kept for:
 * 1. Historical data access
 * 2. Rollback capability
 * 3. Data migration reference
 * 
 * DO NOT USE FOR NEW DEVELOPMENT
 * 
 * @deprecated Replaced by CourseAssignment and RequiredDocumentType in semester-based system
 * @see com.alqude.edu.ArchiveSystem.entity.CourseAssignment
 * @see com.alqude.edu.ArchiveSystem.entity.RequiredDocumentType
 */
@Deprecated(since = "2.0", forRemoval = false)
public class DocumentRequest {
    // ...
}
```

---

## Deprecated Components

### Entities
1. **DocumentRequest** → Replaced by `CourseAssignment` + `RequiredDocumentType`
2. **SubmittedDocument** → Replaced by `DocumentSubmission`
3. **FileAttachment** → Replaced by `UploadedFile`

### Repositories
1. **DocumentRequestRepository** → Replaced by `CourseAssignmentRepository` + `RequiredDocumentTypeRepository`
2. **SubmittedDocumentRepository** → Replaced by `DocumentSubmissionRepository`
3. **FileAttachmentRepository** → Replaced by `UploadedFileRepository`

### Services
1. **DocumentRequestService** → Replaced by `CourseService` + `SubmissionService` + `FileService`
2. **MultiFileUploadService** → Replaced by `FileService`

### Mappers
1. **DocumentRequestMapper** → No direct replacement (new DTOs used)
2. **DocumentRequestMapperManual** → No direct replacement (new DTOs used)

### Exceptions
1. **DocumentRequestException** → Use standard exceptions (`ResourceNotFoundException`, `ValidationException`, etc.)

---

## Handling Deprecation Warnings

### Expected Warnings

When compiling the project, you will see deprecation warnings for:
- Services that use legacy entities for backward compatibility
- Migration code that accesses legacy data
- Test code that validates legacy functionality

**These warnings are EXPECTED and INTENTIONAL.**

### Suppressing Warnings

For code that intentionally uses deprecated components (like migration services), use:

```java
@SuppressWarnings("deprecation")
public class DataMigrationService {
    // This service intentionally uses legacy entities for migration
}
```

### MapStruct Generated Code Warnings

The `DocumentRequestMapperImpl` class is generated by MapStruct and uses deprecated entities. To suppress IDE warnings:

1. **After clean build**, run the fix script:
   ```powershell
   .\fix-mapstruct-warnings.ps1
   ```

2. **Or manually** add `@SuppressWarnings("deprecation")` to the generated class at:
   `target/generated-sources/annotations/com/alqude/edu/ArchiveSystem/mapper/DocumentRequestMapperImpl.java`

**Note:** This is only needed for IDE warnings. Maven compilation already suppresses these warnings via the `-Xlint:-deprecation` compiler argument.

### When to Suppress

Suppress deprecation warnings ONLY when:
1. **Migration Code**: Services that migrate data from legacy to new system
2. **Backward Compatibility**: Services that maintain compatibility with legacy data
3. **Historical Data Access**: Services that provide read-only access to archived data
4. **Rollback Procedures**: Code that supports system rollback

### When NOT to Suppress

DO NOT suppress warnings for:
1. New feature development
2. Bug fixes in new system components
3. API endpoints for new functionality
4. UI components

---

## IDE Behavior

### IntelliJ IDEA / Eclipse / VS Code

Modern IDEs will:
- Show strikethrough text for deprecated components
- Display warning icons
- Show deprecation messages on hover
- Suggest replacements (via `@see` tags)

**This is helpful behavior** - it guides developers away from legacy code.

### Compilation

The Java compiler will emit warnings like:
```
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
```

These warnings do NOT prevent compilation and are informational only.

---

## Migration Timeline

### Phase 1: Current (v2.0)
- ✅ All legacy code marked as deprecated
- ✅ Comprehensive documentation added
- ✅ Database tables archived with comments
- ✅ New system fully functional

### Phase 2: Stabilization (v2.1-v2.5)
- Monitor system stability
- Collect feedback on new system
- Maintain legacy code for rollback
- No removal of deprecated code

### Phase 3: Evaluation (v3.0+)
- Evaluate removal based on:
  - System stability metrics
  - User adoption rates
  - Regulatory requirements
  - Business needs
- Decision: Keep indefinitely OR plan removal

---

## Best Practices

### For Developers

1. **Never use deprecated components for new features**
2. **Always check JavaDoc for replacement components**
3. **Use `@see` tags to find modern alternatives**
4. **Consult LEGACY_CODE_ARCHIVE.md for migration mapping**

### For Code Reviews

1. **Flag any new usage of deprecated components**
2. **Ensure proper `@SuppressWarnings` usage**
3. **Verify migration code is properly documented**
4. **Check that new code uses semester-based system**

### For Testing

1. **Test both legacy and new systems during transition**
2. **Validate data migration accuracy**
3. **Ensure rollback procedures work**
4. **Test historical data access**

---

## Rollback Considerations

If rollback to legacy system is needed:

1. **Code Rollback**: Revert to pre-v2.0 Git tag
2. **Database Rollback**: Use Flyway undo or restore from backup
3. **File System**: Restore file structure from backup
4. **Configuration**: Update application properties

**Note:** Deprecated code is kept specifically to enable rollback without data loss.

---

## Compliance and Auditing

### Regulatory Requirements

Some industries require:
- Historical data retention
- Audit trails
- System rollback capability

**Our deprecation strategy supports these requirements** by:
- Keeping all legacy code functional
- Maintaining database tables with archived data
- Providing views for legacy data access
- Documenting all changes

### Audit Trail

The following provides complete audit trail:
1. Git history showing all changes
2. Database migration scripts (Flyway)
3. System metadata table tracking migrations
4. Comprehensive documentation

---

## FAQ

### Q: Why not remove deprecated code immediately?
**A:** We keep it for historical data access, rollback capability, and regulatory compliance.

### Q: Will deprecated code be maintained?
**A:** No. Deprecated code is frozen and receives no updates except critical security fixes.

### Q: Can I use deprecated code for bug fixes?
**A:** Only if the bug is in legacy data access. New bugs should be fixed in the new system.

### Q: How long will deprecated code remain?
**A:** Indefinitely, unless business requirements change. It's marked `forRemoval = false`.

### Q: What if I need a feature from deprecated code?
**A:** Implement it in the new system. Consult the migration mapping in LEGACY_CODE_ARCHIVE.md.

---

## Related Documentation

- **LEGACY_CODE_ARCHIVE.md** - Complete list of archived components
- **LEGACY_SYSTEM_DOCUMENTATION.md** - Legacy system description
- **MIGRATION_GUIDE.md** - Step-by-step migration guide
- **API_DOCUMENTATION.md** - New API endpoints

---

## Conclusion

Our deprecation strategy balances:
- **Innovation**: New semester-based system with modern features
- **Stability**: Legacy code kept for rollback and historical access
- **Compliance**: Audit trails and data retention requirements
- **Developer Experience**: Clear warnings and documentation

By following this strategy, we ensure a smooth transition while maintaining system reliability and regulatory compliance.
